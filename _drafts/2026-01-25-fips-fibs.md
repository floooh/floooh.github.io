---
layout: post
title: "A Fips retrospective and Fibs introduction
---
I wanted to write a blog post about my silent command-line workhorse
[fips](https://floooh.github.com/fips) for a long time, and now that I actually
get to it, it turns into a restrospective since the [successor](https://github.com/floooh/fibs)
is now in a state where it can replace fips for most projects.

It's a bit hard to describe what those tools do, they're a bit like npm (but
not quite), and a bit like cargo (but not quite), and a bit like
like a game engine asset pipeline (but not quite). I think the most useful
description is that they are the evolution of my C/C++ development workflow
over the last two decades, baked into a command line tool.

Those 'workflow requirements' are basically:

- needs to allow an identical workflow across macOS, Linux and Windows since
  I'm typically switching between those operating systems multiple times a day
  (Windows support also means proper support for the MSVC toolchain instead
  of depending on a UNIX/POSIX shim like mingw or WSL)
- needs to support a mixed command-line / IDE workflow, e.g. I start my
  day in a terminal which then might or move into an IDE (VSCode is pretty
  much perfect for this workflow with its integrated terminal)
- for IDE-based work, at least VSCode, VStudio and Xcode need to be
  supported because each of those has unique features
- it must be possible to easily switch between native and WASM development
  (via Emscripten or the WASI SDK) - including automated SDK setup
- it must be equally trivial to switch to mobile development
  (iOS and Android) - including automated Android SDK/NDS setup
- it must be possible to support easily scriptable build jobs, e.g.
  code generation, copying asset files around or invoking external
  tools like texture converters or shader compilers
- it must be possible to add scripted tasks for things like generating
  sample and documentation webpages, running tests general workflow
  automation
- ...and finally it should be possible to pull in files from remote locations
  but without having to wrestle with git submodules

...there are tools and solutions for all those things, but hardly any that
integrate all those things into a consistent and easy to use package.

The first result of baking such a highly personalized workflow into a tool
was 'fips' which I had started in 2014 and which has since been in use
pretty much every single day since then.

A typical session in fips might look like this:

Let's say I want to do some programming on the sokol-gfx Metal backend
via the [sokol-samples repository](https://github.com/floooh/sokol-samples)

  ```sh
  cd ~/projects/sokol-samples
  ./fips set config sapp-metal-macos-vscode-debug
  ./fips gen
  ./fips open
  ```
...this starts into VSCode with the C/C++ and CMakeTools extension picking
up the CMakeLists.txt file.

Within VSCode I can use the regular `F5-workflow` for building a target
and launching a debug session for a tight edit-compile-debug loop.

...now let's say I want to check if everything still works in Emscripten in WebGL2
and WebGPU, so I'll move down to the VSCode terminal. If the Emscripten SDK hasn't
been setup yet that needs to be done first:

```sh
./fips setup emscripten
```

...then I switch to one of the Emscripten+WebGL2 build configs (first in
debug mode to check if the sokol-gfx validation layer is silent), 'generate'
(the intermediate cmake output files) and then build the whole project:

```sh
./fips set config sapp-webgl2-wasm-ninja-debug
./fips gen
./fibs build
```

...then I run a couple of the sokol samples in WebGL2/WASM mode, this starts
the samples in a web browser:

```sh
./fips run cube-sapp-ui
./fips run mrt-sapp
```

...next if I want to check the WebGPU backend, and build in release mode
for performance I use another build config:

```sh
./fips set config sapp-wgpu-wasm-ninja-release
./fips gen
./fips build
./fips run cube-sapp-ui
```

Building the sokol-samples project also runs build jobs like copying asset files
or running the sokol-shader compiler, and those build jobs are also fully integrated
into the IDE workflow.

...finally the sokol-samples project defines a scripted custom command which can
build and serve the [samples webpage](https://floooh.github.com/sokol-html5)
either for WebGL2 or WebGPU:

```sh
./fips webpage build webgl
./fips webpage build webgpu
```

...the 'serve' subcommand runs a local web server and opens the page
in the web browser:

```sh
./fips webpage serve webgl
./fips webpage serve webgpu
```

...this same `./fips webpage` command is also running when building
and deploying the sokol-samples webpage via Github CI.

Now I also want to do a quick check on Android. First, if the Android SDK/NDK
hasn't been installed yet:

```sh
./fips setup android
```

...then switch to an Android build config, build and run:

```sh
./fips set config sapp-android-ninja-debug
./fips gen
./fips build
./fips run cube-sapp
```

...this installs and runs the `cube-sapp` sample on the Android phone
attached via USB.

The iOS development workflow delegates running and debugging to Xcode:

```sh
./fips set config sapp-metal-ios-xcode-debug
./fips gen
./fips open
```

...this opens Xcode, loads the generated Xcode project and from there
on the development and debugging workflow works as usual either via
the simulator or an attached iPhone.

This is the gist what both `fips` and its successor `fibs` do, allowing
the exact same workflow across Windows, Linux and macOS, quickly switching between
build configs, seamlessly integrating custom build jobs and allowing
easy build automation by scripting new custom commands (like generating
a webpage or running a game asset pipeline).

## What's with those silly names

The old name `fips` never meant anything, the only requirement was that it
is a short and easy to type command. As it turned out later, the main problem with 'fips'
was that it collided with the [Federal Information Processing Standards](https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards).

That was the main reason why the new thing is called `fibs` instead of `fips 2`.
This only collides with some education-related institution down in Bavaria, and I
could finally retcon the name into an abbrevation for **Floh's Infernal Build
System** (I think putting my nickname in there is justified since it's such a highly
personalized and opinionated tool which I don't expect anybody else to use
except for building my C/C++ projects).

## Differences between fips and fibs

Fips did a fine job for over a decade of use, but it had some questionable
design decisions which were hard to fix later without rewriting the whole thing.

But let's first talk about scripting languages.

Fips was written in Python (or rather a mix of cmake-script and Python).
Originally python 2.x, later ported kicking and screaming to python 3.x. This
forced transition from Python 2 to Python 3 was essentially the point where I
said to myself that I need to find an alternative.

Without going too much into rant mode, I don't agree with a single decision
in Python 3 that broke compatibility with Python 2. Python 2 was perfect for
small to medium-sized cross-platform-scripting projects, then Python 3 came
along and wanted to be a "grown up" programming language for large project,
with such genius ideas that a string stream and a binary stream ought to
be entirely different strings instead of just different views on the same
bag of bytes (and working with UTF-8 worked just fine already in Python 2).
Porting to Python 3 was painful, but a one-time job. But this one big
backward compatibility breakage seems to have 'relaxed' the Python
team's stance on backward compatibility. Suddenly it it could happen to
update to a new minor Python version only to find out that something in
the stdlib had a breaking change or behaved slightly differently, so to minimize
maintenance overhead the only solution was to reduce the dependency on the
stdlib, which of course means that the *one* motiviation of using Python
in the first place (the batteries-included stdlib) is gone.

Long story short: out with Python in with Typescript. Typescript isn't only
a better designed langauge than Python, the various JS engines (node, bun,
deno) also started to have better designed stdandard libraries which allowed
the same convenient cross-platform scripting of Python2, but without the
hassle of Python 3.

The final decision to switch to Typescript was then [Deno's](https://deno.com/) ability to
directly import dependencies in the source files without a manifest file
like `requirements.txt` or `package.json`. This means one can write
single-file command line tools which pull their dependencies as needed on
first run. E.g. no `npm install` or `python3 -m pip install -r requirements.txt`
or faffing around with venv's (apparently [uv](https://github.com/astral-sh/uv))
fixes some of the python package management mess, but sorry, too little too
late, and it's still a separate tool to install.

So this is the first big change from fips to fips:

In fibs, a C/C++ build was described by a mix of python, cmake-script
(using tons of custom function - which is kinda frowned upon in the
cmake community), and even YAML.

In fips, everything is just Deno-flavoured Typescript, and usually in a single
`fibs.ts` file in the project root (of course you can split that into multiple
files if it gets too big).

The other differences are a bit more subtle:

1. Fips generally places dependencies into 'sister directories' of the top-level
project directory. The idea was to have a workspace directory where one or
several top-level projects lived side by side sharing the same dependencies, and
those dependencies were 'full' git clones meant for development. This lead to
confusion and anger when people just cloned a fips project and then wondered why
fetching dependencies cluttered their home directory :/ In Fibs all dependencies
are placed in a `.fibs/` subdirectory in the project directory, similar to
`node_modules`, and those dependencies are 'shallow clones' and detached from
HEAD. This means they are not supposed to be developed on, committed or pushed
(again, just like the `node_modules` subdirectory with npm). To do development
work on dependencies, fibs allows to 'link' a local directory anywhere outside
the toplevel project to an import - much the same idea as `npm link`, but less
obscure and easier to use.

2. TODO: fipsification

3.







TODO:

- what's with the name
- differences between fips and fibs
- some fibs code examples
- links to converted repos
- outlook