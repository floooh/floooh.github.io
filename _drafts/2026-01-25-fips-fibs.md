---
layout: post
title: "A Fips retrospective and Fibs introduction
---
I wanted to write a blog post about my silent command-line workhorse
[fips](https://floooh.github.com/fips) for a long time, and now that I actually
get to it, it turns into a restrospective since the [successor](https://github.com/floooh/fibs)
is now in a state where it can replace fips for most projects.

It's a bit hard to describe what those tools do, they're a bit like npm (but
not quite), and a bit like cargo (but not quite), and a bit like
like a game engine asset pipeline (but not quite). I think the most useful
description is that they are the evolution of my C/C++ development workflow
over the last two decades, baked into a command line tool.

Those 'workflow requirements' are basically:

- needs to allow an identical workflow across macOS, Linux and Windows since
  I'm typically switching between those operating systems multiple times a day
  (Windows support also means proper support for the MSVC toolchain instead
  of depending on a UNIX/POSIX shim like mingw or WSL)
- needs to support a mixed command-line / IDE workflow, e.g. I start my
  day in a terminal which then might or move into an IDE (VSCode is pretty
  much perfect for this workflow with its integrated terminal)
- for IDE-based work, at least VSCode, VStudio and Xcode need to be
  supported because each of those has unique features
- it must be possible to easily switch between native and WASM development
  (via Emscripten or the WASI SDK) - including automated SDK setup
- it must be equally trivial to switch to mobile development
  (iOS and Android) - including automated Android SDK/NDS setup
- it must be possible to support easily scriptable build jobs, e.g.
  code generation, copying asset files around or invoking external
  tools like texture converters or shader compilers
- it must be possible to add scripted tasks for things like generating
  sample and documentation webpages, running tests general workflow
  automation
- ...and finally it should be possible to pull in files from remote locations
  but without having to wrestle with git submodules

...there are tools and solutions for all those things, but hardly any that
integrate all those things into a consistent and easy to use package.

The first result of baking such a highly personalized workflow into a tool
was 'fips' which I had started in 2014 and which has since been in use
pretty much every single day since then.

A typical session in fips might look like this:

Let's say I want to do some programming on the sokol-gfx Metal backend
via the [sokol-samples repository](https://github.com/floooh/sokol-samples)

  ```sh
  cd ~/projects/sokol-samples
  ./fips set config sapp-metal-macos-vscode-debug
  ./fips gen
  ./fips open
  ```
...this starts into VSCode with the C/C++ and CMakeTools extension picking
up the CMakeLists.txt file.

Within VSCode I can use the regular `F5-workflow` for building a target
and launching a debug session for a tight edit-compile-debug loop.

...now let's say I want to check if everything still works in Emscripten in WebGL2
and WebGPU, so I'll move down to the VSCode terminal. If the Emscripten SDK hasn't
been setup yet that needs to be done first:

```sh
./fips setup emscripten
```

...then I switch to one of the Emscripten+WebGL2 build configs (first in
debug mode to check if the sokol-gfx validation layer is silent), 'generate'
(the intermediate cmake output files) and then build the whole project:

```sh
./fips set config sapp-webgl2-wasm-ninja-debug
./fips gen
./fibs build
```

...then I run a couple of the sokol samples in WebGL2/WASM mode, this starts
the samples in a web browser:

```sh
./fips run cube-sapp-ui
./fips run mrt-sapp
```

...next if I want to check the WebGPU backend, and build in release mode
for performance I use another build config:

```sh
./fips set config sapp-wgpu-wasm-ninja-release
./fips gen
./fips build
./fips run cube-sapp-ui
```

Building the sokol-samples project also runs build jobs like copying asset files
or running the sokol-shader compiler, and those build jobs are also fully integrated
into the IDE workflow.

...finally the sokol-samples project defines a scripted custom command which can
build and serve the [samples webpage](https://floooh.github.com/sokol-html5)
either for WebGL2 or WebGPU:

```sh
./fips webpage build webgl
./fips webpage build webgpu
```

...the 'serve' subcommand runs a local web server and opens the page
in the web browser:

```sh
./fips webpage serve webgl
./fips webpage serve webgpu
```

...this same `./fips webpage` command is also running when building
and deploying the sokol-samples webpage via Github CI.

Now I also want to do a quick check on Android. First, if the Android SDK/NDK
hasn't been installed yet:

```sh
./fips setup android
```

...then switch to an Android build config, build and run:

```sh
./fips set config sapp-android-ninja-debug
./fips gen
./fips build
./fips run cube-sapp
```

...this installs and runs the `cube-sapp` sample on the Android phone
attached via USB.

The iOS development workflow delegates running and debugging to Xcode:

```sh
./fips set config sapp-metal-ios-xcode-debug
./fips gen
./fips open
```

...this opens Xcode, loads the generated Xcode project and from there
on the development and debugging workflow works as usual either via
the simulator or an attached iPhone.

This is the gist what both `fips` and its successor `fibs` do, allowing
the exact same workflow across Windows, Linux and macOS, quickly switching between
build configs, seamlessly integrating custom build jobs and allowing
easy build automation by scripting new custom commands (like generating
a webpage or running a game asset pipeline).

I totally skipped over the dependency management part, because it happens
mostly invisibly under the hood. One important detail to understand
is that dependencies not only provide 'build dependencies' (e.g. C/C++
libraries), but also new custom build jobs (like invoking the sokol shader
compiler) or custom commands (like building a webpage or installing the
Emscripten SDK).

TODO:

- what's with the name
- differences between fips and fibs
- some fibs code examples
- links to converted repos
- outlook